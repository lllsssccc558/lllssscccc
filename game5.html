<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 俄羅斯方塊遊戲</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a237e, #311b92);
            padding: 20px;
            color: #fff;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            color: #bbbbbb;
            margin-bottom: 25px;
            font-size: 1.1rem;
        }
        
        .game-area {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            justify-content: center;
            margin-bottom: 25px;
        }
        
        .game-board-container {
            display: flex;
            flex-direction: column;
        }
        
        .game-board {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #tetrisCanvas {
            display: block;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 200px;
        }
        
        .info-panel {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #90caf9;
            text-align: center;
            border-bottom: 2px solid rgba(144, 202, 249, 0.3);
            padding-bottom: 8px;
        }
        
        .score-container, .level-container, .lines-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }
        
        .score-value, .level-value, .lines-value {
            font-weight: bold;
            color: #ffcc80;
        }
        
        .next-piece-container {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #nextPieceCanvas {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .high-score-container {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .high-score-value {
            font-size: 2rem;
            font-weight: bold;
            color: #ffcc80;
            margin-top: 5px;
        }
        
        .game-settings {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            justify-content: center;
        }
        
        .difficulty-selector, .game-controls {
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }
        
        .setting-label {
            margin-bottom: 10px;
            color: #90caf9;
            font-weight: 500;
            font-size: 1.1rem;
            text-align: center;
        }
        
        .difficulty-buttons, .control-buttons {
            display: flex;
            gap: 10px;
        }
        
        .difficulty-btn, .control-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            font-size: 1rem;
            flex: 1;
        }
        
        .difficulty-btn {
            background-color: rgba(144, 202, 249, 0.2);
            color: #90caf9;
            border: 1px solid rgba(144, 202, 249, 0.3);
        }
        
        .difficulty-btn.active {
            background-color: #90caf9;
            color: #1a237e;
            box-shadow: 0 0 10px rgba(144, 202, 249, 0.5);
        }
        
        .control-btn {
            background-color: #4caf50;
            color: white;
        }
        
        .control-btn:hover {
            background-color: #388e3c;
            transform: translateY(-2px);
        }
        
        .control-btn.pause {
            background-color: #ff9800;
        }
        
        .control-btn.pause:hover {
            background-color: #f57c00;
        }
        
        .control-btn.reset {
            background-color: #f44336;
        }
        
        .control-btn.reset:hover {
            background-color: #d32f2f;
        }
        
        .game-status {
            text-align: center;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            margin-bottom: 25px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #statusText {
            font-size: 1.8rem;
            font-weight: bold;
            color: #fff;
        }
        
        .game-over {
            color: #ff5252 !important;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .instructions {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 25px;
            border-radius: 12px;
            margin-top: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .instructions h3 {
            margin-bottom: 15px;
            color: #90caf9;
            border-bottom: 2px solid rgba(144, 202, 249, 0.3);
            padding-bottom: 8px;
        }
        
        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .instruction-item {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
        }
        
        .key {
            display: inline-block;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 4px;
            margin: 0 5px;
            font-family: monospace;
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 40px;
            text-align: center;
        }
        
        .footer {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 20px;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .side-panel {
                width: 100%;
                max-width: 400px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .game-settings {
                flex-direction: column;
            }
            
            .instructions-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>俄羅斯方塊</h1>
            <p class="subtitle">經典益智遊戲 - 消除行數獲得高分</p>
        </header>
        
        <div class="game-area">
            <div class="game-board-container">
                <div class="game-board">
                    <canvas id="tetrisCanvas" width="300" height="600"></canvas>
                </div>
            </div>
            
            <div class="side-panel">
                <div class="info-panel">
                    <div class="info-title">遊戲資訊</div>
                    <div class="score-container">
                        <span>當前分數:</span>
                        <span class="score-value" id="currentScore">0</span>
                    </div>
                    <div class="level-container">
                        <span>當前等級:</span>
                        <span class="level-value" id="currentLevel">1</span>
                    </div>
                    <div class="lines-container">
                        <span>消除行數:</span>
                        <span class="lines-value" id="linesCleared">0</span>
                    </div>
                </div>
                
                <div class="next-piece-container">
                    <div class="info-title">下一個方塊</div>
                    <canvas id="nextPieceCanvas" width="120" height="120"></canvas>
                </div>
                
                <div class="high-score-container">
                    <div class="info-title">最高分數</div>
                    <div class="high-score-value" id="highScore">0</div>
                </div>
            </div>
        </div>
        
        <div class="game-status">
            <div id="statusText">點擊"開始遊戲"按鈕開始</div>
        </div>
        
        <div class="game-settings">
            <div class="difficulty-selector">
                <div class="setting-label">遊戲難度</div>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn active" data-difficulty="easy">簡單</button>
                    <button class="difficulty-btn" data-difficulty="normal">普通</button>
                    <button class="difficulty-btn" data-difficulty="hard">困難</button>
                </div>
            </div>
            <div class="game-controls">
                <div class="setting-label">遊戲控制</div>
                <div class="control-buttons">
                    <button class="control-btn" id="startBtn">開始遊戲</button>
                    <button class="control-btn pause" id="pauseBtn" disabled>暫停</button>
                    <button class="control-btn reset" id="resetBtn">重置</button>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>遊戲說明與控制</h3>
            <div class="instructions-grid">
                <div class="instruction-item">
                    <h4>控制方式</h4>
                    <p><span class="key">←</span> 或 <span class="key">A</span>: 左移</p>
                    <p><span class="key">→</span> 或 <span class="key">D</span>: 右移</p>
                    <p><span class="key">↓</span> 或 <span class="key">S</span>: 加速下落</p>
                    <p><span class="key">↑</span> 或 <span class="key">W</span>: 旋轉方塊</p>
                    <p><span class="key">空格</span>: 瞬間落下</p>
                    <p><span class="key">P</span>: 暫停/繼續遊戲</p>
                </div>
                <div class="instruction-item">
                    <h4>遊戲規則</h4>
                    <p>• 方塊會從頂部隨機下落</p>
                    <p>• 移動和旋轉方塊使其填滿水平行</p>
                    <p>• 填滿一整行後該行會消除並得分</p>
                    <p>• 一次消除多行會獲得額外分數</p>
                    <p>• 當方塊堆積到頂部時遊戲結束</p>
                </div>
                <div class="instruction-item">
                    <h4>難度說明</h4>
                    <p>• <strong>簡單</strong>: 方塊下落速度慢，容易控制</p>
                    <p>• <strong>普通</strong>: 標準速度，適合大多數玩家</p>
                    <p>• <strong>困難</strong>: 方塊下落速度快，挑戰反應力</p>
                </div>
                <div class="instruction-item">
                    <h4>計分規則</h4>
                    <p>• 消除1行: 100 × 等級分</p>
                    <p>• 消除2行: 300 × 等級分</p>
                    <p>• 消除3行: 500 × 等級分</p>
                    <p>• 消除4行: 800 × 等級分</p>
                    <p>• 每消除10行升一級</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>HTML5 俄羅斯方塊遊戲 - 使用Canvas和JavaScript實現</p>
    </div>

    <script>
        // 遊戲變數
        const tetrisCanvas = document.getElementById('tetrisCanvas');
        const tetrisCtx = tetrisCanvas.getContext('2d');
        const nextPieceCanvas = document.getElementById('nextPieceCanvas');
        const nextPieceCtx = nextPieceCanvas.getContext('2d');
        const currentScoreElement = document.getElementById('currentScore');
        const currentLevelElement = document.getElementById('currentLevel');
        const linesClearedElement = document.getElementById('linesCleared');
        const highScoreElement = document.getElementById('highScore');
        const statusText = document.getElementById('statusText');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        
        // 遊戲設定
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        
        // 遊戲狀態
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let level = 1;
        let lines = 0;
        let highScore = localStorage.getItem('tetrisHighScore') || 0;
        let gameActive = false;
        let gamePaused = false;
        let gameOver = false;
        let difficulty = 'easy'; // 'easy', 'normal', 'hard'
        let animationFrameId = null;
        let lastUpdateTime = 0;
        let gameSpeed = 0;
        let activeTimeouts = []; // 追蹤活動的setTimeout
        
        // 根據難度設置遊戲參數
        const difficultySettings = {
            easy: { initialSpeed: 1000, speedIncrement: 50, levelSpeedFactor: 0.9 },
            normal: { initialSpeed: 800, speedIncrement: 70, levelSpeedFactor: 0.85 },
            hard: { initialSpeed: 600, speedIncrement: 90, levelSpeedFactor: 0.8 }
        };
        
        // 清理所有活動的setTimeout
        function cleanupTimeouts() {
            activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            activeTimeouts = [];
        }
        
        // 安全的setTimeout，會自動追蹤和清理
        function safeSetTimeout(callback, delay) {
            const timeoutId = setTimeout(() => {
                // 從活動列表中移除
                const index = activeTimeouts.indexOf(timeoutId);
                if (index > -1) {
                    activeTimeouts.splice(index, 1);
                }
                callback();
            }, delay);
            activeTimeouts.push(timeoutId);
            return timeoutId;
        }
        
        // 方塊形狀定義
        const SHAPES = [
            // I
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            // J
            [
                [2, 0, 0],
                [2, 2, 2],
                [0, 0, 0]
            ],
            // L
            [
                [0, 0, 3],
                [3, 3, 3],
                [0, 0, 0]
            ],
            // O
            [
                [4, 4],
                [4, 4]
            ],
            // S
            [
                [0, 5, 5],
                [5, 5, 0],
                [0, 0, 0]
            ],
            // T
            [
                [0, 6, 0],
                [6, 6, 6],
                [0, 0, 0]
            ],
            // Z
            [
                [7, 7, 0],
                [0, 7, 7],
                [0, 0, 0]
            ]
        ];
        
        // 方塊顏色
        const COLORS = [
            '#000000', // 黑色 (背景)
            '#00BCD4', // I - 青色
            '#2196F3', // J - 藍色
            '#FF9800', // L - 橙色
            '#FFEB3B', // O - 黃色
            '#4CAF50', // S - 綠色
            '#9C27B0', // T - 紫色
            '#F44336'  // Z - 紅色
        ];
        
        // 更新最高分顯示
        highScoreElement.textContent = highScore;
        
        // 初始化遊戲板
        function initBoard() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = 0;
                }
            }
        }
        
        // 創建隨機方塊
        function createPiece() {
            const shapeIndex = Math.floor(Math.random() * SHAPES.length);
            return {
                shape: SHAPES[shapeIndex],
                colorIndex: shapeIndex + 1,
                row: 0,
                col: Math.floor(COLS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2)
            };
        }
        
        // 繪製單個方塊
        function drawBlock(ctx, x, y, colorIndex) {
            const color = COLORS[colorIndex];
            
            // 方塊主體
            ctx.fillStyle = color;
            ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            
            // 方塊邊框
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            
            // 方塊內部高光效果
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(x, y, BLOCK_SIZE - 2, 3);
            ctx.fillRect(x, y, 3, BLOCK_SIZE - 2);
            
            // 方塊內部陰影效果
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(x + BLOCK_SIZE - 3, y + 3, 3, BLOCK_SIZE - 3);
            ctx.fillRect(x + 3, y + BLOCK_SIZE - 3, BLOCK_SIZE - 3, 3);
        }
        
        // 繪製遊戲板
        function drawBoard() {
            // 繪製背景
            tetrisCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
            
            // 繪製網格線
            tetrisCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            tetrisCtx.lineWidth = 0.5;
            
            // 垂直線
            for (let c = 0; c <= COLS; c++) {
                tetrisCtx.beginPath();
                tetrisCtx.moveTo(c * BLOCK_SIZE, 0);
                tetrisCtx.lineTo(c * BLOCK_SIZE, tetrisCanvas.height);
                tetrisCtx.stroke();
            }
            
            // 水平線
            for (let r = 0; r <= ROWS; r++) {
                tetrisCtx.beginPath();
                tetrisCtx.moveTo(0, r * BLOCK_SIZE);
                tetrisCtx.lineTo(tetrisCanvas.width, r * BLOCK_SIZE);
                tetrisCtx.stroke();
            }
            
            // 繪製已固定的方塊
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawBlock(tetrisCtx, c * BLOCK_SIZE, r * BLOCK_SIZE, board[r][c]);
                    }
                }
            }
            
            // 繪製當前下落的方塊
            if (currentPiece) {
                drawPiece(currentPiece);
            }
            
            // 繪製預覽位置
            if (currentPiece && gameActive) {
                const previewPiece = {...currentPiece};
                while (!checkCollision(previewPiece.row + 1, previewPiece.col, previewPiece.shape)) {
                    previewPiece.row++;
                }
                
                // 繪製半透明的預覽方塊
                for (let r = 0; r < previewPiece.shape.length; r++) {
                    for (let c = 0; c < previewPiece.shape[r].length; c++) {
                        if (previewPiece.shape[r][c]) {
                            const color = COLORS[previewPiece.colorIndex];
                            tetrisCtx.fillStyle = color + '80'; // 添加透明度
                            tetrisCtx.fillRect(
                                (previewPiece.col + c) * BLOCK_SIZE, 
                                (previewPiece.row + r) * BLOCK_SIZE, 
                                BLOCK_SIZE, 
                                BLOCK_SIZE
                            );
                            
                            tetrisCtx.strokeStyle = color;
                            tetrisCtx.lineWidth = 1;
                            tetrisCtx.strokeRect(
                                (previewPiece.col + c) * BLOCK_SIZE, 
                                (previewPiece.row + r) * BLOCK_SIZE, 
                                BLOCK_SIZE, 
                                BLOCK_SIZE
                            );
                        }
                    }
                }
            }
        }
        
        // 繪製當前方塊
        function drawPiece(piece) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c]) {
                        drawBlock(
                            tetrisCtx, 
                            (piece.col + c) * BLOCK_SIZE, 
                            (piece.row + r) * BLOCK_SIZE, 
                            piece.colorIndex
                        );
                    }
                }
            }
        }
        
        // 繪製下一個方塊
        function drawNextPiece() {
            // 清除畫布
            nextPieceCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            nextPieceCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
            
            if (!nextPiece) return;
            
            // 計算居中位置
            const offsetX = (nextPieceCanvas.width - nextPiece.shape[0].length * BLOCK_SIZE/2) / 2;
            const offsetY = (nextPieceCanvas.height - nextPiece.shape.length * BLOCK_SIZE/2) / 2;
            
            // 繪製下一個方塊
            for (let r = 0; r < nextPiece.shape.length; r++) {
                for (let c = 0; c < nextPiece.shape[r].length; c++) {
                    if (nextPiece.shape[r][c]) {
                        nextPieceCtx.fillStyle = COLORS[nextPiece.colorIndex];
                        nextPieceCtx.fillRect(
                            offsetX + c * BLOCK_SIZE/2, 
                            offsetY + r * BLOCK_SIZE/2, 
                            BLOCK_SIZE/2, 
                            BLOCK_SIZE/2
                        );
                        
                        nextPieceCtx.strokeStyle = '#000';
                        nextPieceCtx.lineWidth = 1;
                        nextPieceCtx.strokeRect(
                            offsetX + c * BLOCK_SIZE/2, 
                            offsetY + r * BLOCK_SIZE/2, 
                            BLOCK_SIZE/2, 
                            BLOCK_SIZE/2
                        );
                        
                        // 方塊內部高光效果
                        nextPieceCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        nextPieceCtx.fillRect(
                            offsetX + c * BLOCK_SIZE/2, 
                            offsetY + r * BLOCK_SIZE/2, 
                            BLOCK_SIZE/2 - 2, 
                            2
                        );
                        nextPieceCtx.fillRect(
                            offsetX + c * BLOCK_SIZE/2, 
                            offsetY + r * BLOCK_SIZE/2, 
                            2, 
                            BLOCK_SIZE/2 - 2
                        );
                    }
                }
            }
        }
        
        // 檢查碰撞
        function checkCollision(row, col, shape) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newRow = row + r;
                        const newCol = col + c;
                        
                        // 檢查是否超出邊界或與其他方塊重疊
                        if (
                            newCol < 0 || 
                            newCol >= COLS || 
                            newRow >= ROWS || 
                            (newRow >= 0 && board[newRow][newCol])
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // 旋轉方塊
        function rotatePiece(piece) {
            // 創建旋轉後的形狀
            const rotated = [];
            const size = piece.shape.length;
            
            for (let r = 0; r < size; r++) {
                rotated[r] = [];
                for (let c = 0; c < size; c++) {
                    rotated[r][c] = piece.shape[size - 1 - c][r];
                }
            }
            
            // 檢查旋轉後是否會碰撞
            if (!checkCollision(piece.row, piece.col, rotated)) {
                return rotated;
            }
            
            // 如果旋轉後會碰撞，嘗試牆踢 (wall kick)
            // 嘗試向左移動
            if (!checkCollision(piece.row, piece.col - 1, rotated)) {
                piece.col -= 1;
                return rotated;
            }
            
            // 嘗試向右移動
            if (!checkCollision(piece.row, piece.col + 1, rotated)) {
                piece.col += 1;
                return rotated;
            }
            
            // 如果都不行，返回原始形狀
            return piece.shape;
        }
        
        // 固定方塊到遊戲板
        function lockPiece() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        const boardRow = currentPiece.row + r;
                        const boardCol = currentPiece.col + c;
                        
                        // 如果方塊超出頂部，遊戲結束
                        if (boardRow < 0) {
                            endGame();
                            return;
                        }
                        
                        board[boardRow][boardCol] = currentPiece.colorIndex;
                    }
                }
            }
            
            // 檢查並清除完整的行
            clearLines();
            
            // 生成新方塊
            currentPiece = nextPiece;
            nextPiece = createPiece();
            drawNextPiece();
            
            // 檢查新方塊是否能夠放置
            if (checkCollision(currentPiece.row, currentPiece.col, currentPiece.shape)) {
                endGame();
            }
        }
        
        // 清除完整的行
        function clearLines() {
            let linesCleared = 0;
            
            for (let r = ROWS - 1; r >= 0; r--) {
                // 檢查行是否完整
                let isLineFull = true;
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] === 0) {
                        isLineFull = false;
                        break;
                    }
                }
                
                // 如果行完整，移除該行並將上方所有行下移
                if (isLineFull) {
                    // 將上方所有行下移
                    for (let y = r; y > 0; y--) {
                        for (let c = 0; c < COLS; c++) {
                            board[y][c] = board[y - 1][c];
                        }
                    }
                    
                    // 清空頂部行
                    for (let c = 0; c < COLS; c++) {
                        board[0][c] = 0;
                    }
                    
                    linesCleared++;
                    r++; // 重新檢查當前位置（因為行已經下移）
                }
            }
            
            // 如果消除了行，更新分數
            if (linesCleared > 0) {
                updateScore(linesCleared);
                lines += linesCleared;
                linesClearedElement.textContent = lines;
                
                // 每消除10行升一級
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    currentLevelElement.textContent = level;
                    updateGameSpeed();
                }
            }
        }
        
        // 更新分數
        function updateScore(linesCleared) {
            // 根據消除的行數計算分數
            const linePoints = [100, 300, 500, 800];
            const points = linePoints[linesCleared - 1] * level;
            
            score += points;
            currentScoreElement.textContent = score;
            
            // 更新最高分
            if (score > highScore) {
                highScore = score;
                highScoreElement.textContent = highScore;
                localStorage.setItem('tetrisHighScore', highScore);
            }
        }
        
        // 更新遊戲速度
        function updateGameSpeed() {
            const settings = difficultySettings[difficulty];
            
            // 計算新速度（隨等級增加而加快）
            gameSpeed = Math.max(100, settings.initialSpeed * Math.pow(settings.levelSpeedFactor, level - 1));
        }
        
        // 移動方塊
        function movePiece(deltaRow, deltaCol) {
            if (!gameActive || gamePaused || !currentPiece) return false;
            
            const newRow = currentPiece.row + deltaRow;
            const newCol = currentPiece.col + deltaCol;
            
            if (!checkCollision(newRow, newCol, currentPiece.shape)) {
                currentPiece.row = newRow;
                currentPiece.col = newCol;
                return true;
            }
            
            // 如果是向下移動且碰撞，則固定方塊
            if (deltaRow > 0) {
                lockPiece();
            }
            
            return false;
        }
        
        // 落下方塊到底部
        function dropPiece() {
            if (!gameActive || gamePaused || !currentPiece) return;
            
            while (movePiece(1, 0)) {
                // 持續向下移動直到碰撞
            }
        }
        
        // 遊戲主循環 (使用requestAnimationFrame)
        function gameLoop(currentTime) {
            if (!gameActive || gameOver) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            
            if (gamePaused) {
                // 如果遊戲暫停，繼續下一幀但不更新遊戲狀態
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            
            // 計算時間差，控制遊戲速度
            if (lastUpdateTime === 0) {
                lastUpdateTime = currentTime;
            }
            
            const deltaTime = currentTime - lastUpdateTime;
            
            // 如果時間差足夠大，更新遊戲狀態
            if (deltaTime >= gameSpeed) {
                // 移動方塊向下
                if (!movePiece(1, 0)) {
                    // 如果無法向下移動，方塊已經被鎖定
                }
                
                // 繪製遊戲板
                drawBoard();
                lastUpdateTime = currentTime - (deltaTime % gameSpeed); // 保留多餘時間
            }
            
            // 繼續下一幀
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // 開始遊戲
        function startGame() {
            if (gameActive && !gamePaused) return;
            
            // 清理現有資源
            cleanupTimeouts();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            initBoard();
            score = 0;
            level = 1;
            lines = 0;
            
            currentScoreElement.textContent = score;
            currentLevelElement.textContent = level;
            linesClearedElement.textContent = lines;
            
            currentPiece = createPiece();
            nextPiece = createPiece();
            
            gameActive = true;
            gamePaused = false;
            gameOver = false;
            
            startBtn.textContent = '重新開始';
            pauseBtn.disabled = false;
            pauseBtn.textContent = '暫停';
            
            statusText.textContent = '遊戲進行中';
            statusText.classList.remove('game-over');
            
            drawBoard();
            drawNextPiece();
            
            // 根據難度設置遊戲速度
            updateGameSpeed();
            
            // 重置時間追蹤
            lastUpdateTime = 0;
            
            // 開始遊戲循環
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // 暫停/繼續遊戲
        function togglePause() {
            if (!gameActive || gameOver) return;
            
            gamePaused = !gamePaused;
            
            if (gamePaused) {
                pauseBtn.textContent = '繼續';
                statusText.textContent = '遊戲已暫停';
            } else {
                pauseBtn.textContent = '暫停';
                statusText.textContent = '遊戲進行中';
                
                // 重置時間追蹤以避免暫停後立即更新
                lastUpdateTime = 0;
            }
        }
        
        // 結束遊戲
        function endGame() {
            gameActive = false;
            gameOver = true;
            
            // 停止動畫幀
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            statusText.textContent = `遊戲結束！最終分數: ${score}`;
            statusText.classList.add('game-over');
            
            pauseBtn.disabled = true;
        }
        
        // 重置遊戲
        function resetGame() {
            // 清理現有資源
            cleanupTimeouts();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            gameActive = false;
            gamePaused = false;
            gameOver = false;
            
            startBtn.textContent = '開始遊戲';
            pauseBtn.disabled = true;
            pauseBtn.textContent = '暫停';
            
            statusText.textContent = '點擊"開始遊戲"按鈕開始';
            statusText.classList.remove('game-over');
            
            initBoard();
            drawBoard();
            drawNextPiece();
            
            currentScoreElement.textContent = '0';
            currentLevelElement.textContent = '1';
            linesClearedElement.textContent = '0';
            
            // 重置時間追蹤
            lastUpdateTime = 0;
        }
        
        // 事件監聽器
        startBtn.addEventListener('click', startGame);
        
        pauseBtn.addEventListener('click', togglePause);
        
        resetBtn.addEventListener('click', resetGame);
        
        // 難度選擇
        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                // 更新按鈕狀態
                difficultyButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // 更新難度
                difficulty = button.getAttribute('data-difficulty');
                
                // 如果遊戲正在運行，更新速度
                if (gameActive && !gamePaused) {
                    updateGameSpeed();
                }
            });
        });
        
        // 鍵盤控制
        document.addEventListener('keydown', (e) => {
            if (!gameActive || gamePaused) return;
            
            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePiece(0, -1);
                    drawBoard();
                    break;
                    
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePiece(0, 1);
                    drawBoard();
                    break;
                    
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePiece(1, 0);
                    drawBoard();
                    break;
                    
                case 'ArrowUp':
                case 'w':
                case 'W':
                    currentPiece.shape = rotatePiece(currentPiece);
                    drawBoard();
                    break;
                    
                case ' ':
                    dropPiece();
                    drawBoard();
                    break;
                    
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
            
            // 防止默認行為（如滾動頁面）
            if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });
        
        // 添加基本的可訪問性支援
        function addAccessibilitySupport() {
            // 為按鈕添加ARIA標籤
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                if (!button.getAttribute('aria-label')) {
                    const text = button.textContent || button.id;
                    button.setAttribute('aria-label', text);
                }
            });
            
            // 為畫布添加描述
            tetrisCanvas.setAttribute('aria-label', '俄羅斯方塊遊戲主畫布');
            tetrisCanvas.setAttribute('role', 'application');
            nextPieceCanvas.setAttribute('aria-label', '下一個方塊預覽畫布');
            
            // 為遊戲區域添加標題
            const gameContainer = document.querySelector('.container');
            if (gameContainer && !gameContainer.getAttribute('aria-labelledby')) {
                const header = document.querySelector('header h1');
                if (header) {
                    header.id = header.id || 'game-title';
                    gameContainer.setAttribute('aria-labelledby', header.id);
                }
            }
            
            // 為狀態文本添加實時區域
            statusText.setAttribute('aria-live', 'polite');
            statusText.setAttribute('aria-atomic', 'true');
        }
        
        // 添加錯誤處理
        function addErrorHandling() {
            // 全局錯誤處理
            window.addEventListener('error', (event) => {
                console.error('俄羅斯方塊遊戲錯誤:', event.error);
                // 可以在此處添加錯誤報告或用戶通知
            });
            
            // 未處理的Promise拒絕
            window.addEventListener('unhandledrejection', (event) => {
                console.error('俄羅斯方塊遊戲未處理的Promise拒絕:', event.reason);
            });
            
            // Canvas渲染錯誤處理
            const originalFillRect = CanvasRenderingContext2D.prototype.fillRect;
            CanvasRenderingContext2D.prototype.fillRect = function(...args) {
                try {
                    return originalFillRect.apply(this, args);
                } catch (error) {
                    console.error('Canvas渲染錯誤:', error);
                    // 嘗試恢復
                    try {
                        this.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } catch (e) {
                        // 忽略清理錯誤
                    }
                }
            };
        }
        
        // 設置canvas大小
        function resizeCanvas() {
            try {
                // 保持遊戲板比例
                const container = document.querySelector('.game-board-container');
                if (!container) return;
                
                const size = Math.min(container.clientWidth, 400);
                tetrisCanvas.width = Math.floor(size / COLS) * COLS;
                tetrisCanvas.height = Math.floor(tetrisCanvas.width / COLS) * ROWS;
                
                // 重新計算方塊大小
                BLOCK_SIZE = tetrisCanvas.width / COLS;
                
                // 重繪遊戲板
                drawBoard();
                drawNextPiece();
            } catch (error) {
                console.error('調整canvas大小時發生錯誤:', error);
            }
        }
        
        // 清理函數
        function cleanup() {
            // 清理時間戳
            cleanupTimeouts();
            
            // 停止動畫幀
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // 移除事件監聽器
            if (window._tetrisResizeHandler) {
                window.removeEventListener('resize', window._tetrisResizeHandler);
                delete window._tetrisResizeHandler;
            }
        }
        
        // 初始化遊戲
        function initGame() {
            // 清理現有資源
            cleanup();
            
            // 初始調整canvas大小
            resizeCanvas();
            
            // 監聽窗口大小變化
            window._tetrisResizeHandler = resizeCanvas;
            window.addEventListener('resize', window._tetrisResizeHandler);
            
            // 初始化遊戲
            initBoard();
            drawBoard();
            
            // 創建初始方塊用於顯示
            nextPiece = createPiece();
            drawNextPiece();
            
            // 初始化遊戲速度
            updateGameSpeed();
            
            // 添加可訪問性支援
            addAccessibilitySupport();
            
            // 添加錯誤處理
            addErrorHandling();
        }
        
        // 頁面卸載時清理
        window.addEventListener('beforeunload', cleanup);
        
        // 初始化遊戲
        initGame();
    </script>
</body>
</html>